<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Class Transport&lt;T&gt; </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Class Transport&lt;T&gt; ">
      
      <meta name="description" content="A FIFO queue of ordered discrete items.">
      <link rel="icon" href="../logo.svg">
      <link rel="stylesheet" href="../public/docfx.min.css">
      <link rel="stylesheet" href="../public/main.css">
      <meta name="docfx:navrel" content="">
      <meta name="docfx:tocrel" content="toc.html">
      
      <meta name="docfx:rel" content="../">
      
      
      
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="ManagedReference">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../index.html">
            <img id="logo" class="svg" src="../logo.svg" alt="Marymoor Studios Core">
            Marymoor Studios Core
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="MarymoorStudios.Core.Promises.Transport`1">



  <h1 id="MarymoorStudios_Core_Promises_Transport_1" data-uid="MarymoorStudios.Core.Promises.Transport`1" class="text-break">
Class Transport&lt;T&gt;  
  </h1>

  <div class="facts text-secondary">
    <dl><dt>Namespace</dt><dd><a class="xref" href="MarymoorStudios.html">MarymoorStudios</a>.<a class="xref" href="MarymoorStudios.Core.html">Core</a>.<a class="xref" href="MarymoorStudios.Core.Promises.html">Promises</a></dd></dl>
  <dl><dt>Assembly</dt><dd>MarymoorStudios.Core.Promises.dll</dd></dl>
  </div>

  <div class="markdown summary"><p>A FIFO queue of ordered discrete items.</p>
</div>
  <div class="markdown conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public abstract class Transport&lt;T&gt; : IDisposable</code></pre>
  </div>



  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>T</code></dt>
    <dd><p>The item type.</p>
</dd>
  </dl>

  <dl class="typelist inheritance">
    <dt>Inheritance</dt>
    <dd>
      <div><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.object">object</a></div>
      <div><span class="xref">Transport&lt;T&gt;</span></div>
    </dd>
  </dl>

  <dl class="typelist implements">
    <dt>Implements</dt>
    <dd>
      <div><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.idisposable">IDisposable</a></div>
    </dd>
  </dl>

  <dl class="typelist derived">
    <dt>Derived</dt>
    <dd>
      <div><a class="xref" href="MarymoorStudios.Core.Promises.RingBuffer-1.html">RingBuffer&lt;T&gt;</a></div>
      <div><a class="xref" href="MarymoorStudios.Core.Rpc.Net.TcpTransport.html">TcpTransport</a></div>
    </dd>
  </dl>

  <dl class="typelist inheritedMembers">
    <dt>Inherited Members</dt>
    <dd>
    <div>
      <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.object.gettype">object.GetType()</a>
    </div>
    <div>
      <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.object.memberwiseclone">object.MemberwiseClone()</a>
    </div>
    <div>
      <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.object.tostring">object.ToString()</a>
    </div>
    <div>
      <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.object.equals#system-object-equals(system-object)">object.Equals(object)</a>
    </div>
    <div>
      <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.object.equals#system-object-equals(system-object-system-object)">object.Equals(object, object)</a>
    </div>
    <div>
      <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.object.referenceequals">object.ReferenceEquals(object, object)</a>
    </div>
    <div>
      <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.object.gethashcode">object.GetHashCode()</a>
    </div>
  </dd></dl>




  <h2 id="MarymoorStudios_Core_Promises_Transport_1_remarks">Remarks</h2>
  <div class="markdown level0 remarks"><p>
The <a class="xref" href="MarymoorStudios.Core.Promises.Transport-1.html">Transport&lt;T&gt;</a> is a FIFO for communicating a totally ordered series of "items" from a
producer to a consumer.  Though the <a class="xref" href="MarymoorStudios.Core.Promises.Transport-1.html">Transport&lt;T&gt;</a> is thread-safe, it supports only a single
producer and a single consumer at one time.  The producer and consumer MAY (and usually do) operate in
separate threads.  (The producer and consumer MAY operate in a single thread, but care should be taken when
waiting on the handles (see below) to ensure the thread is not live-locked.)
</p>
<p>
A <a class="xref" href="MarymoorStudios.Core.Promises.Transport-1.html">Transport&lt;T&gt;</a> takes "ownership" of any item written to the queue and subsequently
transfers "ownership" to the consumer when the item is read.  The consumer is responsible for releasing or
disposing any linear resources transferred through the queue (including memory buffers).
</p>
<p>
The <a class="xref" href="MarymoorStudios.Core.Promises.Transport-1.html">Transport&lt;T&gt;</a> supports efficient blocking for both producer and consumer operations
through the <a class="xref" href="MarymoorStudios.Core.Promises.Transport-1.html#MarymoorStudios_Core_Promises_Transport_1_ProducerEvent">ProducerEvent</a> and <a class="xref" href="MarymoorStudios.Core.Promises.Transport-1.html#MarymoorStudios_Core_Promises_Transport_1_ConsumerEvent">ConsumerEvent</a> properties respectively.  The
producer handle is guaranteed to be signaled ONLY AFTER a failed enqueue operation due to the queue being
full. Similarly, the consumer handle is guaranteed to be signaled ONLY AFTER a failed dequeue operation due
to the queue being empty.  Both the producer and the consumer should loop performing their operations until a
blocking condition is so indicated before attempting to wait on their respective handle.  The wait handles
MAY over-signal (i.e. signal even though the corresponding operation will fail due to resource constraints).
The caller should be prepared to wait again if that happens.
</p>
<p>
All events will be signaled at least once if the buffer is "closed" by either party.  Events are NOT
guaranteed to be signaled MORE THAN ONCE after a <a class="xref" href="MarymoorStudios.Core.Promises.Transport-1.html#MarymoorStudios_Core_Promises_Transport_1_Close_MarymoorStudios_Core_Promises_TransportFlags_">Close(TransportFlags)</a>, so both parties MUST aggressively
respond to closure indications.  It is "safe" to call any operation after a successful "close" by either (or
both) parties.  Producers will receive a persistent <a class="xref" href="MarymoorStudios.Core.Rpc.Exceptions.AbortedException.html">AbortedException</a> on all enqueue attempts
after closure.  Consumers will receive a persistent <a class="xref" href="MarymoorStudios.Core.Rpc.Exceptions.AbortedException.html">AbortedException</a> on all dequeue attempts
ONLY AFTER all pending items have been delivered (allowing the consumer to release and dispose all pending
resources safely). Both parties MUST call <a class="xref" href="MarymoorStudios.Core.Promises.Transport-1.html#MarymoorStudios_Core_Promises_Transport_1_Close_MarymoorStudios_Core_Promises_TransportFlags_">Close(TransportFlags)</a> at least once.
</p>
<p>
In general the consumer "owns" the <a class="xref" href="MarymoorStudios.Core.Promises.Transport-1.html">Transport&lt;T&gt;</a> and is responsible for calling
<a class="xref" href="MarymoorStudios.Core.Promises.Transport-1.html#MarymoorStudios_Core_Promises_Transport_1_Dispose">Dispose()</a> when it is no longer needed.  The consumer MUST ensure that the producer has released
any references to the <a class="xref" href="MarymoorStudios.Core.Promises.Transport-1.html#MarymoorStudios_Core_Promises_Transport_1_ProducerEvent">ProducerEvent</a> which it does so by calling <a class="xref" href="MarymoorStudios.Core.Promises.Transport-1.html#MarymoorStudios_Core_Promises_Transport_1_Close_MarymoorStudios_Core_Promises_TransportFlags_">Close(TransportFlags)</a> on its side
and receiving a <code>true</code> response. The producer should NEVER access any part of the
<a class="xref" href="MarymoorStudios.Core.Promises.Transport-1.html">Transport&lt;T&gt;</a> or its handles AFTER calling <a class="xref" href="MarymoorStudios.Core.Promises.Transport-1.html#MarymoorStudios_Core_Promises_Transport_1_Close_MarymoorStudios_Core_Promises_TransportFlags_">Close(TransportFlags)</a> for its side.  The consumer MUST
release any references to the <a class="xref" href="MarymoorStudios.Core.Promises.Transport-1.html#MarymoorStudios_Core_Promises_Transport_1_ConsumerEvent">ConsumerEvent</a> BEFORE calling <a class="xref" href="MarymoorStudios.Core.Promises.Transport-1.html#MarymoorStudios_Core_Promises_Transport_1_Dispose">Dispose()</a>. If the
consumer initiates closure it should:
</p>
<p>
<ol><li>Call <a class="xref" href="MarymoorStudios.Core.Promises.Transport-1.html#MarymoorStudios_Core_Promises_Transport_1_TryDequeue__0__">TryDequeue(out T)</a> in a loop until the queue is empty, then</li><li>
Call <a class="xref" href="MarymoorStudios.Core.Promises.Transport-1.html#MarymoorStudios_Core_Promises_Transport_1_Close_MarymoorStudios_Core_Promises_TransportFlags_">Close(TransportFlags)</a> again.  If <a class="xref" href="MarymoorStudios.Core.Promises.Transport-1.html#MarymoorStudios_Core_Promises_Transport_1_Close_MarymoorStudios_Core_Promises_TransportFlags_">Close(TransportFlags)</a> returns <code>true</code> then it is "safe" to
dispose, otherwise.
</li><li>
Wait on <a class="xref" href="MarymoorStudios.Core.Promises.Transport-1.html#MarymoorStudios_Core_Promises_Transport_1_ConsumerEvent">ConsumerEvent</a> until it signals (indicating that the producer has called
<a class="xref" href="MarymoorStudios.Core.Promises.Transport-1.html#MarymoorStudios_Core_Promises_Transport_1_Close_MarymoorStudios_Core_Promises_TransportFlags_">Close(TransportFlags)</a>) and then dispose.
</li></ol>

<p>
It is "safe" for the producer to dispose the <a class="xref" href="MarymoorStudios.Core.Promises.Transport-1.html">Transport&lt;T&gt;</a> ONLY IF the consumer was never
successfully started.
</p>
</div>


  <h2 class="section" id="constructors">Constructors
</h2>


  <a id="MarymoorStudios_Core_Promises_Transport_1__ctor_" data-uid="MarymoorStudios.Core.Promises.Transport`1.#ctor*"></a>

  <h3 id="MarymoorStudios_Core_Promises_Transport_1__ctor" data-uid="MarymoorStudios.Core.Promises.Transport`1.#ctor">
  Transport()
  
  </h3>

  <div class="markdown level1 summary"></div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">protected Transport()</code></pre>
  </div>













  <h2 class="section" id="properties">Properties
</h2>


  <a id="MarymoorStudios_Core_Promises_Transport_1_ConsumerEvent_" data-uid="MarymoorStudios.Core.Promises.Transport`1.ConsumerEvent*"></a>

  <h3 id="MarymoorStudios_Core_Promises_Transport_1_ConsumerEvent" data-uid="MarymoorStudios.Core.Promises.Transport`1.ConsumerEvent">
  ConsumerEvent
  
  </h3>

  <div class="markdown level1 summary"><p>Event to efficiently signal the consumer when items are available to read.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public abstract WaitHandle ConsumerEvent { get; }</code></pre>
  </div>





  <h4 class="section">Property Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.waithandle">WaitHandle</a></dt>
    <dd></dd>
  </dl>




  <h4 class="section" id="MarymoorStudios_Core_Promises_Transport_1_ConsumerEvent_remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>This event only signals on the transition between an empty queue and having at least one item, so
the caller should read the queue to completion before waiting on this event.</p>
</div>




  <a id="MarymoorStudios_Core_Promises_Transport_1_ProducerEvent_" data-uid="MarymoorStudios.Core.Promises.Transport`1.ProducerEvent*"></a>

  <h3 id="MarymoorStudios_Core_Promises_Transport_1_ProducerEvent" data-uid="MarymoorStudios.Core.Promises.Transport`1.ProducerEvent">
  ProducerEvent
  
  </h3>

  <div class="markdown level1 summary"><p>Event to efficiently signal the producer when slots are available to write.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public abstract WaitHandle ProducerEvent { get; }</code></pre>
  </div>





  <h4 class="section">Property Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.waithandle">WaitHandle</a></dt>
    <dd></dd>
  </dl>




  <h4 class="section" id="MarymoorStudios_Core_Promises_Transport_1_ProducerEvent_remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>This event only signals on the transition between a full queue and having at least <code>threshold</code>
items, so the caller should write to the queue until full before waiting on this event.</p>
</div>




  <h2 class="section" id="methods">Methods
</h2>


  <a id="MarymoorStudios_Core_Promises_Transport_1_Close_" data-uid="MarymoorStudios.Core.Promises.Transport`1.Close*"></a>

  <h3 id="MarymoorStudios_Core_Promises_Transport_1_Close_MarymoorStudios_Core_Promises_TransportFlags_" data-uid="MarymoorStudios.Core.Promises.Transport`1.Close(MarymoorStudios.Core.Promises.TransportFlags)">
  Close(TransportFlags)
  
  </h3>

  <div class="markdown level1 summary"><p>Marks the buffer as closed atomically.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public abstract bool Close(TransportFlags flags = TransportFlags.Closed)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>flags</code> <a class="xref" href="MarymoorStudios.Core.Promises.TransportFlags.html">TransportFlags</a></dt>
    <dd><p>Indicates which side(s) to close.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.boolean">bool</a></dt>
    <dd><p>True if the both sides have closed, false if only one side has closed as of this call.</p>
</dd>
  </dl>







  <h4 class="section" id="MarymoorStudios_Core_Promises_Transport_1_Close_MarymoorStudios_Core_Promises_TransportFlags__remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>No more items can be inserted after this call returns.</p>
<p>Either side (producer or consumer) can close the buffer.</p>
<p>
Typically, the consumer will continue to read items until <a class="xref" href="MarymoorStudios.Core.Promises.Transport-1.html#MarymoorStudios_Core_Promises_Transport_1_TryDequeue__0__">TryDequeue(out T)</a> indicates the
closure has been seen.  This ensures that all buffered items have been removed, regardless of which side
closed first.
</p>
<p>Both sides should close the buffer before the last side to close can then safely dispose.</p>
</div>




  <a id="MarymoorStudios_Core_Promises_Transport_1_Dispose_" data-uid="MarymoorStudios.Core.Promises.Transport`1.Dispose*"></a>

  <h3 id="MarymoorStudios_Core_Promises_Transport_1_Dispose" data-uid="MarymoorStudios.Core.Promises.Transport`1.Dispose">
  Dispose()
  
  </h3>

  <div class="markdown level1 summary"></div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void Dispose()</code></pre>
  </div>













  <a id="MarymoorStudios_Core_Promises_Transport_1_Dispose_" data-uid="MarymoorStudios.Core.Promises.Transport`1.Dispose*"></a>

  <h3 id="MarymoorStudios_Core_Promises_Transport_1_Dispose_System_Boolean_" data-uid="MarymoorStudios.Core.Promises.Transport`1.Dispose(System.Boolean)">
  Dispose(bool)
  
  </h3>

  <div class="markdown level1 summary"><p>Standard dispose pattern for subclasses.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">protected virtual void Dispose(bool disposing)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>disposing</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.boolean">bool</a></dt>
    <dd><p>True if both native and managed resources are being disposed.  False if only native
resources (i.e. in finalizer).</p>
</dd>
  </dl>












  <a id="MarymoorStudios_Core_Promises_Transport_1_Finalize_" data-uid="MarymoorStudios.Core.Promises.Transport`1.Finalize*"></a>

  <h3 id="MarymoorStudios_Core_Promises_Transport_1_Finalize" data-uid="MarymoorStudios.Core.Promises.Transport`1.Finalize">
  ~Transport()
  
  </h3>

  <div class="markdown level1 summary"><p>Finalizer.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">protected ~Transport()</code></pre>
  </div>













  <a id="MarymoorStudios_Core_Promises_Transport_1_TryDequeue_" data-uid="MarymoorStudios.Core.Promises.Transport`1.TryDequeue*"></a>

  <h3 id="MarymoorStudios_Core_Promises_Transport_1_TryDequeue__0__" data-uid="MarymoorStudios.Core.Promises.Transport`1.TryDequeue(`0@)">
  TryDequeue(out T)
  
  </h3>

  <div class="markdown level1 summary"><p>Attempt to remove an item from the front of the buffer.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public abstract bool TryDequeue(out T item)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>item</code> <span class="xref">T</span></dt>
    <dd><p>If successful, the item removed from the buffer, <code>default</code> otherwise.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.boolean">bool</a></dt>
    <dd><p>True if an item was successfully remove, false if the buffer is empty.</p>
</dd>
  </dl>







  <h4 class="section" id="MarymoorStudios_Core_Promises_Transport_1_TryDequeue__0___remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>If <code class="paramref">item</code> is successfully removed the caller takes ownership of it and is
responsible for releasing its resources.  If the attempt to dequeue fails then <code class="paramref">item</code> is
<code>default</code>.</p>
</div>

  <h4 class="section">Exceptions</h4>
  <dl class="parameters">
    <dt><a class="xref" href="MarymoorStudios.Core.Rpc.Exceptions.AbortedException.html">AbortedException</a></dt>
    <dd><p>If the buffer has been closed AND all buffered items have been read.</p>
</dd>
  </dl>



  <a id="MarymoorStudios_Core_Promises_Transport_1_TryEnqueue_" data-uid="MarymoorStudios.Core.Promises.Transport`1.TryEnqueue*"></a>

  <h3 id="MarymoorStudios_Core_Promises_Transport_1_TryEnqueue__0__" data-uid="MarymoorStudios.Core.Promises.Transport`1.TryEnqueue(`0@)">
  TryEnqueue(ref T)
  
  </h3>

  <div class="markdown level1 summary"><p>Attempt to insert an item at the end of the buffer.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public abstract bool TryEnqueue(ref T item)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>item</code> <span class="xref">T</span></dt>
    <dd><p>The item to be inserted.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.boolean">bool</a></dt>
    <dd><p>True if the item was inserted, false if the buffer is full.</p>
</dd>
  </dl>







  <h4 class="section" id="MarymoorStudios_Core_Promises_Transport_1_TryEnqueue__0___remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>On a successful insert the buffer takes ownership of <code class="paramref">item</code> and its value is set to
<code>default</code>.  If <code class="paramref">item</code> cannot be inserted (either because 'full' or 'closed') then false
is returned and <code class="paramref">item</code> is unmodified (still owned by the caller); the caller is then
responsible for releasing any resources.</p>
</div>

  <h4 class="section">Exceptions</h4>
  <dl class="parameters">
    <dt><a class="xref" href="MarymoorStudios.Core.Rpc.Exceptions.AbortedException.html">AbortedException</a></dt>
    <dd><p>If the buffer has already been closed.</p>
</dd>
  </dl>




</article>



      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
