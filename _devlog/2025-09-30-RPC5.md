---
order: 7
title: "RPC Part 5: Sessions"
date: 2025-09-30 09:32:00 -0700
bg: white
color: black
excerpt: "Sessions (and their transports) give eventual values a well-defined lifetime."
featured: "true"
---
# RPC Part 5: Sessions
--------

## Intro
In the [previous post][devlog-post6] we learned about Sequences and Streams.  We examined some of the issues that
streaming solves including memory limitations, network latency, traffic minimization, flow control, and backpressure. In
this post, the last in this series focused on the [MSC][MSC] RPC system, we will think a little about Sessions, session
lifetime and what impact session termination has on eventual values.

Back in the post [RPC Part 3: Capability Exchange][devlog-post5] we introduced the concept of the [Root
Capability][define-root].  The root was the _first_ capability that we acquired.  We observed that the root was received
"when successfully initiating a new connected session".  But what does that mean?  What is a session?  How do we connect
one?  How long does it last?  What happens when the connection is terminated?  We will try to answer these questions in
this post.

## Transport vs. Session
[Promise RPC][promise-rpc], like many message passing systems, involves two different layers of abstraction.  Each is
responsible for different aspects of the communication.

* **Transport:**  
  The transport layer defines the mechanics of physically moving data between two endpoints.  It is usually also
  responsible for data ordering, reliability and integrity.

* **Session:**  
  The session layer defines the logical protocol for communication.  It is responsible for designating the structure of
  messages, the format of message serialization, and the semantics of message exchange.  This layer is also responsible
  for authentication and prototcol version negotiations.

## Transports
Fundamentally, transports move groups of bytes (often called _packets_) from one endpoint to another.

A transport can be stateless, such as UDP, where each packet is sent _fire-and-forget_.  In a stateless transport, any
tracking (such as determining if delivery was successful) _must_ be implemented by a higher layer.  Alternatively, a
transport can be stateful, like TCP, where reliability, and integrity are part of the transport itself.  Stateful
transports _may_ keep track of the order in which multiple packets are sent to the same destination.  If subsequent
packets are delivered in the same order they were sent then the transport is called _ordered_ (otherwise _unordered_).

A transport can be connectionless (e.g. UDP) where the destination address must be provided _each_ time for _each_
packet.  Or, a transport can be connection-oriented (e.g. TCP) where a _unique label_ is first established between the
two endpoints to represent the pairing.  An appropriate label might be a name or a number.  All subsequent packets sent
on the connection are then automatically delivered to the destination.  Connection-oriented transports usually allow for
multiple simultaneous independent connections between the same two endpoints  (each having a different label), thus
allowing multiple independent communication streams, each with an independent lifetime.  

Transports can even be layered, where one transport is built on top of another.  For example QUIC is a reliable,
ordered, connection-oriented transport built over UDP which is an unreliable, unordered, connectionless transport. Steam
Networking is a transport with multiple implementations each layered over a different transport including UDP, TCP and
even WebSockets.

Not all transports use the network.  For instance, a memory-based transport can be constructed from a pair of FIFO
queues pointing in opposites directions.  Memory-based transports are often used to communicate between threads in a
multithreaded program.  A shared-memory transport can be built from a block of memory mapped simultaneously into the
memory address space of two different processes running on the same machine.  Such a transport is commonly used for
interprocess communication (IPC).  A bidirectional pipe is another common transport used for IPC between a child process
and its parent.

The benefit of separating the Transport Layer from the Session Layer is that we can choose different transports
depending on the distance and communication medium between the endpoints.  If the two endpoints are in the same process
then a memory-based transport will be faster and far more efficient than a network one.  If two endpoints are on
different machines, then a network transport will be required, but we might choose TCP if the endpoints are both on a
LAN but choose Steam Networking if the two endpoints are behind firewalls.

[Promise RPC][promise-rpc], like many message passing systems, implements a variety of transports out-of-the-box.  This
provides flexibility in performance and reachability that allows our games to achieve efficient communication between
all their components wherever they may run (in-process, out-of-process, or across the network).

## Sessions
A Session implements the logical protocol for communication between two parties.  A session defines the shape and
meaning of the messages that make up a message passing system.  The session's logic defines how these messages are
encoded into bytes for transmission over the chosen Transport.  Messages fall into two broad categories:

* **Control Messages:**  
  Control messages are exchanged privately by the session implementation at both endpoints.  They are used to negotiate
  configurational and operational information used by the message passing system to maintain its internal state. Control
  messages may appear directly in the main application ordering, or they may be sent and received using a separate
  ordering that is independent of the application interactions.  When sent using an alternative ordering they are called
  out-of-band (OOB) messages.

* **(Application) Messages:**  
  All other messages are Application Messages (or simply _messages_).  Application messages carry the data and method
  intents that make up an RPC system.  In all of our previous posts in this series we have discussed the _messages_ in a
  message passing system.  These are those _messages_.  A message passing system usually works in conjunction with a
  serialization library that allows programs to define their own data contracs and methods for inclusion within an
  application message.  (We'll talk more about the [MSC Serialization][promise-ser] libary in a future post.)

Though there are many Transport implementations, there is only a single Session implementation.  The Session
implementation separates one message passing system from another.  In a program, the message passing system maintains a
set of tables representing the state of the communiciation between all of the connected parties including a collection
of zero or more session instances.  Each session instance represents an active communication between the current process
and another party.  Each instance consists of two endpoints (one representing the current process and the other its
remote peer), a transport instance (that provides a mechanism for the two endpoints to communicate bidirectionally), and
the internal state that is unique to that session.

## Session Establishment
When a new session is created the two parties need to agree on a number of things before they can communicate further:

1. Each endpoint MUST be reachable through the transport by their peer.  If the transported is a connection-oriented one
   then a connection must first be established.  If the endpoints must share resources like in-memory queues, or shared
   memory then references to these resources must be exchanged.  How these things happen is transport-dependent.
2. The version of the session protocol to use (if there is more than one) MUST be established.  If the two parties are
   not using compatible versions of the session protocol then they will not understand each other's messages and further
   communication will be impossible.  Some session implementations may support multiple versions, in which case, the two
   parties will identify and agree on which to use for this session.
3. The parties (may optionally) identity themselves through an agreed upon Authentication mechanism.  In [Promise
   RPC][promise-rpc] authentication is required (we'll talk more about [MSC Identity][promise-identity] in a future
   post), but some message passing systems support unauthenticated sessions.
4. Lastly, the parties may optionally exchange additional configuration information.  In [Promise RPC][promise-rpc] this
   includes the [Root Capability][define-root].

We can say that a session is _Initiated_ when these four steps are begun.  If any of these steps fails then the session
is immediately _Terminated_.  For instance, if the transport fails to exchange packets between the parties (where
failure is defined by the transport itself) then the session is terminated.  If the two parties cannot agree on a
protocol version then the session is terminated.  If the parties fail to successfully authentication each other, _or_ if
either party refuses the session with the remote peer based on their presented identity then the session is terminated.
And lastly, if the two parties cannot agree on the appropriate configuration then the session is terminated.

If all of these steps succeed, then we say that the session is _Established_.  Once established, the parties are free to
send messages as defined by the agreed upon version of the session protocol.




## Conclusion
In this post we talked about streaming sequences including `Sequence<T>` and `Bytes`.  We examined some of the issues
that streaming solves including memory limitations, network latency, traffic minimization, flow control, and
backpressure.  Lastly, we looked at some unique characterisitcs of the [Promise RPC][promise-rpc] library's
implementation of streaming sequences.

This is Part 4 of our look at the [MSC][MSC] RPC system.  In the next and final part, we'll look at channel lifetime,
aborts and cancellation.  Until next time, code on!

## Previous
Read the [previous post][devlog-post6] in this series.

## Feedback
Write us with [feedback][feedback].

## See Also
* [All Posts][all-posts]
* [Glossary][glossary]
* [MSC (Marymoor Studios Core libraries)][MSC]

[MSC]: https://github.com/MarymoorStudios/Core
[all-posts]: /devlog.html
[devlog-post5]: /devlog/2025-07-29-RPC3
[devlog-post6]: /devlog/2025-08-26-RPC4
[feedback]: mailto:feedback@marymoorstudios.com
[glossary]: /devlog/Glossary
[define-root]: /devlog/Glossary#root-capability
[promise-rpc]: https://www.nuget.org/packages/MarymoorStudios.Core.Rpc/
[promise-ser]: https://www.nuget.org/packages/MarymoorStudios.Core.Serialization/
[promise-identity]: https://www.nuget.org/packages/MarymoorStudios.Core.Rpc.Identity
