---
order: 7
title: "RPC Part 5: Session Lifetime"
date: 2025-09-30 09:32:00 -0700
bg: white
color: black
excerpt: "All eventual values must be well-defined even when a session's lifetime ends."
featured: "true"
---
# RPC Part 5: Session Lifetime
--------

## Intro
In the [previous post][devlog-post6] we learned about Sequences and Streams.  We examined some of the issues that
streaming solves including memory limitations, network latency, traffic minimization, flow control, and backpressure.
In this post, the last in this series focused on the [MSC][MSC] RPC system, we will think a little about session
lifetime and what impact that has on eventual values.

Back in the post [RPC Part 3: Capability Exchange][devlog-post5] we introduced the concept of the [Root
Capability][define-root].  The root was the _first_ capability that we acquired.  We observed that the root was received
"when successfully initiating a new connected session".  But what does that mean?  What is a session?  How do we connect
one?  How long does it last?  What happens when the connection is terminated?  We will try to answer these questions in
this post.

## Transport vs. Session
[MSC RPC][MSC], like many message passing systems, involves two different layers of abstraction.  Each is responsible
for different aspects of the communication.

* **Transport:**  
  The transport layer defines the mechanics of physically moving data between two endpoints.  It is responsible for data
  ordering, reliability and integrity.

* **Session:**  
  The session layer defines the logical protocol for communication.  It is responsible for defining the structure of
  messages, the format of message serialization, and the semantics of message exchange.

## Transports
A transport can be stateless, such as UDP, where each packet is sent _fire-and-forget_.  In a stateless transport, any
tracking (such as determining if delivery was successful) _must_ be implemented by a higher layer.  Alternatively, a
transport can be stateful, like TCP, where ordering, reliability, and integrity are part of the transport itself.  

A transport can be connectionless (e.g. UDP) where the destination address must be provided _each_ time for _each_
packet.  Or, a transport can be connection-oriented (e.g. TCP) where a _unique label_ is first established between the
two endpoints.  An appropriate label might be a name or a number.  All subsequent packets sent on the connection are
automatically delivered to the destination address.  Connection-oriented transports usually allow for multiple
simultaneous independent connections between the same two endpoints  (each having a different label), thus allowing
multiple independent communication streams, each with an independent lifetime.  

Transports can even be layered, where one transport is built on top of another.  For example QUIC is a reliable,
ordered, connection-oriented transport built over UDP which is an unreliable, unordered, connectionless transport. Steam
Networking is another transport with multiple implementations layered over different transports like UDP, TCP and even
WebSockets.

Not all transports use the network.  For instance, a memory-based transport can be constructed from a pair of FIFO
queues pointing in opposites directions.  Memory-based transports are often used to communicate between threads in a
multithreaded program.  A shared-memory transport can be built from a block of memory mapped simultaneously into the
memory address space of two different processes running on the same machine.  Such a transport is commonly used for
interprocess communication (IPC).  A bidirectional pipe is another common transport used for IPC between a child process
and its parent.

The benefit of separating the Transport Layer from the Session Layer is that we can choose different transports
depending on the distance and communication medium between the endpoints.  If the two endpoints are in the same process
then a memory-based transport will be faster and far more efficient than a network one.  If two endpoints are on
different machines, then a network transport will be required, but we might choose TCP if the endpoints are both on a
LAN but choose Steam Networking if the two endpoints are behind firewalls.

[MSC RPC][MSC] implements a variety of transports out of the box, providing flexibility in performance and reach and
thus allowing our games to achieve efficient communication between all components.

## Sessions

## Conclusion
In this post we talked about streaming sequences including `Sequence<T>` and `Bytes`.  We examined some of the issues
that streaming solves including memory limitations, network latency, traffic minimization, flow control, and
backpressure.  Lastly, we looked at some unique characterisitcs of the [Promise RPC][promise-rpc] library's
implementation of streaming sequences.

This is Part 4 of our look at the [MSC][MSC] RPC system.  In the next and final part, we'll look at channel lifetime,
aborts and cancellation.  Until next time, code on!

## Previous
Read the [previous post][devlog-post6] in this series.

## Feedback
Write us with [feedback][feedback].

## See Also
* [All Posts][all-posts]
* [Glossary][glossary]
* [MSC (Marymoor Studios Core libraries)][MSC]

[MSC]: https://github.com/MarymoorStudios/Core
[all-posts]: /devlog.html
[devlog-post5]: /devlog/2025-07-29-RPC3
[devlog-post6]: /devlog/2025-08-26-RPC4
[feedback]: mailto:feedback@marymoorstudios.com
[glossary]: /devlog/Glossary
[define-root]: /devlog/Glossary#root-capability
[promise-rpc]: https://www.nuget.org/packages/MarymoorStudios.Core.Rpc/
