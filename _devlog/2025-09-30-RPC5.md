---
order: 7
title: "RPC Part 5: Sessions"
date: 2025-09-30 09:32:00 -0700
bg: white
color: black
excerpt: "Sessions (and their transports) give eventual values a well-defined lifetime."
featured: "true"
---
# RPC Part 5: Sessions
--------

## Intro
In the [previous post][devlog-post6] we learned about Sequences and Streams.  We examined some of the issues that
streaming solves including memory limitations, network latency, traffic minimization, flow control, and backpressure. In
this post, the last in this series focused on the [MSC][MSC] RPC system, we will think a little about Sessions, session
lifetime and what impact session termination has on eventual values.

Back in the post [RPC Part 3: Capability Exchange][devlog-post5] we introduced the concept of the [Root
Capability][define-root].  The root was the _first_ capability that we acquired.  We observed that the root was received
"when successfully initiating a new connected session".  But what does that mean?  What is a session?  How do we connect
one?  How long does it last?  What happens when the connection is terminated?  We will try to answer these questions in
this post.

## Transport vs. Session
[MSC RPC][MSC], like many message passing systems, involves two different layers of abstraction.  Each is responsible
for different aspects of the communication.

* **Transport:**  
  The transport layer defines the mechanics of physically moving data between two endpoints.  It is usually also
  responsible for data ordering, reliability and integrity.

* **Session:**  
  The session layer defines the logical protocol for communication.  It is responsible for designating the structure of
  messages, the format of message serialization, and the semantics of message exchange.  This layer is also responsible
  for authentication and prototcol version negotiations.

## Transports
Fundamentally, transports move groups of bytes (often called _packets_) from one endpoint to another.

A transport can be stateless, such as UDP, where each packet is sent _fire-and-forget_.  In a stateless transport, any
tracking (such as determining if delivery was successful) _must_ be implemented by a higher layer.  Alternatively, a
transport can be stateful, like TCP, where reliability, and integrity are part of the transport itself.  Stateful
transports _may_ keep track of the order in which multiple packets are sent to the same destination.  If subsequent
packets are delivered in the same order they were sent then the transport is called _ordered_ (otherwise _unordered_).

A transport can be connectionless (e.g. UDP) where the destination address must be provided _each_ time for _each_
packet.  Or, a transport can be connection-oriented (e.g. TCP) where a _unique label_ is first established between the
two endpoints to represent the pairing.  An appropriate label might be a name or a number.  All subsequent packets sent
on the connection are then automatically delivered to the destination.  Connection-oriented transports usually allow for
multiple simultaneous independent connections between the same two endpoints  (each having a different label), thus
allowing multiple independent communication streams, each with an independent lifetime.  

Transports can even be layered, where one transport is built on top of another.  For example QUIC is a reliable,
ordered, connection-oriented transport built over UDP which is an unreliable, unordered, connectionless transport. Steam
Networking is a transport with multiple implementations each layered over a different transport including UDP, TCP and
even WebSockets.

Not all transports use the network.  For instance, a memory-based transport can be constructed from a pair of FIFO
queues pointing in opposites directions.  Memory-based transports are often used to communicate between threads in a
multithreaded program.  A shared-memory transport can be built from a block of memory mapped simultaneously into the
memory address space of two different processes running on the same machine.  Such a transport is commonly used for
interprocess communication (IPC).  A bidirectional pipe is another common transport used for IPC between a child process
and its parent.

The benefit of separating the Transport Layer from the Session Layer is that we can choose different transports
depending on the distance and communication medium between the endpoints.  If the two endpoints are in the same process
then a memory-based transport will be faster and far more efficient than a network one.  If two endpoints are on
different machines, then a network transport will be required, but we might choose TCP if the endpoints are both on a
LAN but choose Steam Networking if the two endpoints are behind firewalls.

[MSC RPC][MSC], like many message passing systems, implements a variety of transports out-of-the-box.  This provides
flexibility in performance and reachability that allows our games to achieve efficient communication between all their
components wherever they may run (in-process, out-of-process, or across the network).

## Sessions
A Session implements the logical protocol for communication between two parties.  A session defines the shape and
meaning of the messages that make up a message passing system.  The session's logic defines how these messages are
encoded into bytes for transmission over the chosen Transport.  Messages fall into two broad categories:

* **Control Messages:**  
  Control messages are exchanged privately by the session implementation at both endpoints.  They are used to negotiate
  configurational and operational information used by the message passing system to maintain its internal state. Control
  messages may appear directly in the main application ordering, or they may be sent and received using a separate
  ordering that is independent of the application interactions.  When sent using an alternative ordering they are called
  out-of-band (OOB) messages.

* **(Application) Messages:**  
  All other messages are Application Messages (or simply _messages_).  Application messages carry the data and intents
  that make up a RPC system.  In all of our previous posts in this series we have discussed the _messages_ in a message
  passing system. These are those _messages_.

Though there are many Transport implementations, there is only a single Session implementation.  The Session
implementation separates one message passing system from another.  In a program, the message passing system maintains a
set of tables representing the state of the communiciation between all of the connected parties and a collection of zero
or more session instances.  Each session instance represents an active communication between the current process and
another endpoint.  Each session instance consists of two endpoints (one representing the current process and the other
its remote peer), a transport instance that provides a mechanism for the two endpoints to communicate bidirectionally,
and additional internal state unique to the session.

## Session Establishment


## Conclusion
In this post we talked about streaming sequences including `Sequence<T>` and `Bytes`.  We examined some of the issues
that streaming solves including memory limitations, network latency, traffic minimization, flow control, and
backpressure.  Lastly, we looked at some unique characterisitcs of the [Promise RPC][promise-rpc] library's
implementation of streaming sequences.

This is Part 4 of our look at the [MSC][MSC] RPC system.  In the next and final part, we'll look at channel lifetime,
aborts and cancellation.  Until next time, code on!

## Previous
Read the [previous post][devlog-post6] in this series.

## Feedback
Write us with [feedback][feedback].

## See Also
* [All Posts][all-posts]
* [Glossary][glossary]
* [MSC (Marymoor Studios Core libraries)][MSC]

[MSC]: https://github.com/MarymoorStudios/Core
[all-posts]: /devlog.html
[devlog-post5]: /devlog/2025-07-29-RPC3
[devlog-post6]: /devlog/2025-08-26-RPC4
[feedback]: mailto:feedback@marymoorstudios.com
[glossary]: /devlog/Glossary
[define-root]: /devlog/Glossary#root-capability
[promise-rpc]: https://www.nuget.org/packages/MarymoorStudios.Core.Rpc/
