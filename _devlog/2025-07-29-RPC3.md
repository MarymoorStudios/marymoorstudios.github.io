---
order: 5
title: "RPC Part 3: Remote Object Identity"
date: 2025-06-30 8:48:25 -0700
bg: white
color: black
excerpt: "Object identity is a powerful modeling tool."
featured: "true"
---
# RPC Part 3: Remote Object Identity
--------

## Intro
In the previous post we examined the 5 phases of an RPC call's lifecycle and how they related to message ordering.  We
saw how non-sequential ordering was desirable in some cases, but undesirable in others.  Finally we proposed a rule,
**Interface Order**, for when dispatch ordering should match call ordering.  The rule supports developers' intuitions
about causal ordering and therefore increases the likelihood of code correctness.  In this post we will further refine
our ideas around order scoping to a narrower, yet more powerful scope.

## Instance Order
In the [previous post][devlog-post4] we talked about using Interface Order to impose a total ordering on the messages
sent to a chat room embedded in a game lobby.  Ordering guarantees prevented undesirable reordering of both (a) two
messages from the same user, and (b) replies by other users.  For illustration purposes, let's simplify this example by
defining a pure chat interface (without the game lobby).  This might look like:

```csharp
[Eventual]
interface IChat
{
  Promise Chat(string message);
}
```

Assuming `c` is a `ChatProxy`, this enables write code like:

```csharp
c.Chat("Let's get going.  We need to:");
c.Chat("* Put gas in the car.");
c.Chat("* Drive to the event.");
```

(It might be unfortunate if those messages get reordered!)  What if we want to support more than one chat room at the
same time (perhaps with different groups of people talking about independent things)? Now we'll need some way to
indicate which chat room each message was intended for.  We could add a parameter to the `Chat` method:

```csharp
[Eventual]
interface IChat
{
  Promise Chat(int chatRoomId, string message);
}
```

This works... but has some _issues_.  Who allocates the id?  How does the caller learn the id?  How do you prevent the
same id from being used for multiple rooms at the same time?  How do you prevent malicious users from guessing the id of
rooms they aren't a member of?  When a room is destroyed, how to you reuse the id (so you don't run out)?  During
message dispatch, how do you find the data structure that manages that specific room's data?  I'm sure you can imagine
solutions to some of these problems, but let's ignore them for now.  Now we can write:

```csharp
c.Chat(videoGameReviewRoomId, "Marymoor Studios [b]rocks[/b]!");
c.Chat(cookingRecipesRoomId, "No, the secret is to use half-and-half instead of milk!");
```

Interface Order guarantees that all calls to the same interface are ordered.  These are both calls to the `IChat`
interface, but do we really need our messages to the _Cooking Recipes_ room to be ordered with messages to the _Video
Game Review_ room?  Probably not.  We want our ordering guarantees to apply _only_ to the chat room, not the entire
interface.  We could define two different interfaces:

```csharp
[Eventual]
interface IVideoGameReviewChat
{
  Promise Chat(string message);
}

[Eventual]
interface ICookingRecipesChat
{
  Promise Chat(string message);
}
```

Now we have the ordering scope that we want, and we are able to simplify the interface once again by removing those
troublesome `chatRoomId` parameters.  But this clearly won't scale.  In most cases we don't really want a static set of
chat rooms defined at compile-time.  We want the system to be able to create (and destroy) new chat rooms at will, but
still get the ordering guarantees we need.  What we want is more than one **Instance** of the same Interface.  Then we
can define **Instance Order** instead of Interface Order.  Instance Order says that calls are ordered if they are made
on the _same proxy instance_ (rather than to the same Interface).

If we had instances then we can go back to the original `IChat` design we started with above.  We have two proxy
instances, each of which is of type `ChatProxy` and we can write the code

```csharp
videoGameReview.Chat("Marymoor Studios [b]rocks[/b]!");
cookingRecipes.Chat("No, the secret is to use half-and-half instead of milk!");
```

Now, we get _exactly and only_ the ordering that we desire.  All calls made on the same chat room are ordered, but calls
made to different rooms are independent.

## Capability Exchange
But, how did we get the two proxy instances to begin with?  The caller can't just create them because the callee has to
"know" which chat room each refers to.  The caller needs _the callee to provide them_ already imbued with the proper
chat room association.  To make this possible our message passing system will need a new feature not yet discussed:
**Capability Exchange**.  Capability exchange allows the payload of a message (including response messages) to carry
what a **Capability**.

Like [Distributed Computing][distributed-computing], there is an entire field of computer science focused on studying
the design of secure systems through the use of **[Capability-based Security][capability-based_security]**.  A full
examination of capability-based security is beyond the scope of this devlog entry.  But for the purposes of our
discussion we can define a **Capability** as:

> **Capability**
> 
> A communicable, unforgeable, reference to a, possibly remote, object along with an associated set of access rights.

_Communicable_ merely means that it can be transferred (in our case through the message passing system).  _Unforgeable_
means that you can't create one without already having access to the object it refers to.  This implies that there is
**no way** for a malicous caller to create a reference to an object that the server doesn't want them to have access to.
The _associated set of access rights_ means you can perform "actions" with the reference.  In our case each capability
will be a strongly typed proxy, and the Interface type of that proxy defines a set of methods, and the set of methods
are exactly the set of "actions" that you are authorized to perform when holding the capability.

Using capability exchange, we can now define a second interface for our chat server:

```csharp
[Eventual]
interface IChatRoomManager
{
  ChatProxy CreateRoom(string name);
}
```

This allows us to then write the code above:

```csharp

ChatProxy videoGameReview = crm.CreateRoom("Video Game Review");
ChatProxy cookingRecipes = crm.CreateRoom("Cooking Recipes");

videoGameReview.Chat("Marymoor Studios [b]rocks[/b]!");
cookingRecipes.Chat("No, the secret is to use half-and-half instead of milk!");
```



## Conclusion
In this post we talked about RPC method lifecycles, message ordering, and using interfaces to scope ordering
constraints.  We discussed what semantics the [Promise RPC library](
https://www.nuget.org/packages/MarymoorStudios.Core.Rpc/) implements for message ordering, and gave some examples about
how that might be useful.

This is Part 2 of our look at the [MSC][MSC] RPC system.  In Part 3 and beyond we'll look at remote object identity
through capability exchange, streaming with sequences and bytes, and finally we'll see how channel lifetime relates to
aborts and cancellation. Until next time, code on!

## Previous
Read the [previous post][devlog-post4] in this series.

## Feedback
Write us with [feedback][feedback].

## See Also
* [All Posts][all-posts]
* [Glossary][glossary]
* [MSC (Marymoor Studios Core libraries)][MSC]

[MSC]: https://github.com/MarymoorStudios/Core
[all-posts]: /devlog.html
[devlog-post2]: /devlog/2025-04-23-Ordering
[devlog-post3]: /devlog/2025-05-29-RPC1
[devlog-post4]: /devlog/2025-06-30-RPC2
[feedback]: mailto:feedback@marymoorstudios.com
[glossary]: /devlog/Glossary
[async-keyword]: https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/async
[await-keyword]: https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/await
[distributed-computing]: https://en.wikipedia.org/wiki/Distributed_computing
[capability-based_security]: https://en.wikipedia.org/wiki/Capability-based_security
