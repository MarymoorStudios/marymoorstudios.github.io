---
order: 5
title: "RPC Part 3: Remote Object Identity"
date: 2025-06-30 8:48:25 -0700
bg: white
color: black
excerpt: "Object identity is a powerful modeling tool."
featured: "true"
---
# RPC Part 3: Remote Object Identity
--------

## Intro
In the previous post we examined the 5 phases of an RPC call's lifecycle and how they related to message ordering.  We
saw how non-sequential ordering was desirable in some cases, but undesirable in others.  Finally we proposed a rule,
**Interface Order**, for when dispatch order should match call order.  The rule supported developers' intuitions about
causal ordering and therefore increased the likelihood of code correctness.  In this post we will further refine our
ideas around ordering to a narrower and yet more powerful scope.

## Instance Order
In the [previous post][devlog-post4] we talked about using Interface Order to impose a total ordering on the messages
sent to a chat room embedded in a game lobby.  The ordering guarantees prevented undesirable reordering of both (a) two
messages from the same user, and (b) replies by other users.  For this discussion let's simplify this example by
defining a pure chat interface (without the game lobby).  This might look like:

```csharp
[Eventual]
interface IChat
{
  Promise Chat(string message);
}
```

Assuming `c` is a `ChatProxy`, we can write code like:

```csharp
await c.Chat("Let's get going.  We need to:");
await c.Chat(" * Put gas in the car.");
await c.Chat(" * Drive to the event.");
```

(It might be unfortunate if those last two messages were reordered!)  

What if we want to support more than one chat room at the same time (perhaps with different groups of people, talking
about different things)? We'll need some way to indicate which chat room each message was intended for.  We could add a
parameter to the `Chat` method:

```csharp
[Eventual]
interface IChat
{
  Promise Chat(int chatRoomId, string message);
}
```

This works... but has some _issues_.  Who allocates the id?  How does the caller learn the id?  How do you prevent the
same id from being used for multiple rooms at the same time?  How do you prevent malicious users from guessing the id of
rooms they aren't a member of?  When a room is destroyed, how to you reuse the id (so you don't run out)?  During
message dispatch, how do you find the data structure that manages that specific room's data?  I'm sure you can imagine
solutions to some of these problems, but let's ignore them for now and look at what this interface might be used.  We
can now write:

```csharp
c.Chat(videoGameReviewRoomId, "Marymoor Studios [b]rocks[/b]!");
c.Chat(cookingRecipesRoomId, "No, the secret is to use half-and-half instead of milk!");
```

Interface Order guarantees that all calls to the same interface are ordered.  These are both calls to the `IChat`
interface.  But, do we really need our messages to the _Cooking Recipes_ room to be ordered with messages to the _Video
Game Review_ room?  Probably not.  We want our ordering guarantees to apply _only_ to the chat room, not the entire
interface.  We could define two different interfaces:

```csharp
[Eventual]
interface IVideoGameReviewChat
{
  Promise Chat(string message);
}

[Eventual]
interface ICookingRecipesChat
{
  Promise Chat(string message);
}
```

Now we have the ordering scope that we want, and we are able to simplify the interface once again by removing those
troublesome `chatRoomId` parameters.  But this clearly won't scale.  We don't really want a static set of chat rooms
defined at compile-time.  We want the system to be able to be able to create (and destroy) new chat rooms at will, but
we still want to get ordering guarantees.  What we want is more than one **Instance** of the _same_ Interface.  Then we
could define **Instance Order** instead of Interface Order.  Instance Order says that calls are ordered if they are made
on the _same proxy instance_ (rather than to the same Interface).

If we had instances then we can go back to the original `IChat` design we started with above, but have two instances of
it.  We would have two proxies, each of which is of type `ChatProxy` and we can write the code:

```csharp
await videoGameReview.Chat("Marymoor Studios [b]rocks[/b]!");
await cookingRecipes.Chat("No, the secret is to use half-and-half instead of milk!");
```

Now, we get _exactly and only_ the ordering that we desire.  All calls made on the same chat room are ordered, but calls
made to different rooms are independent.

## Capability Exchange
But, how did we get the two proxy instances to begin with?  The caller can't just create them because the callee has to
"know" which chat room each refers to.  The caller needs _the callee to provide them_ already imbued with the proper
chat room association.  To make this possible our message passing system will need a new feature not yet discussed:
**Capability Exchange**.  Capability Exchange allows the payload of a message (including response messages) to carry
a **Capability**.

Like [Distributed Computing][distributed-computing], there is an entire field of computer science focused on studying
the design of secure systems through the use of **[Capability-based Security][capability-based_security]**.  A full
examination of capability-based security is beyond the scope of this devlog.  But for the purposes of our discussion we
can define a **Capability** as:

> **Capability**
> 
> A communicable, unforgeable, reference to a (possibly remote) object along with an associated set of access rights.

_Communicable_ merely means that it can be transferred (in our case through the message passing system).  _Unforgeable_
means that you can't create one without already having access to the object it refers to.  This implies that there is
**no way** for a malicous caller to create a reference to an object that the server didn't give them. The _associated
set of access rights_ means you can perform _actions_ on the object by using the reference.  In our case each capability
is a strongly typed proxy, and the Interface type of that proxy defines a set of methods, and the set of methods are
exactly the set of _actions_ that you are _authorized_ to perform when holding the capability.  

Lastly, the _object_ referenced by the proxy is a unique instantiation.  When the message passing system dispatches a
call it _implicitly includes a reference to the target object automatically_ (like the `this` pointer in an
[object-oriented programming language][oop]).  The object pointed to by a capability has 4 interesting characteristics:

  1. **State:**  
     It has state.  The object closes over its own state variables, which can be accessed within its _actions_ when they
     are dispatched (via the implicit object reference provided by the message passing system).

  2. **Identity:**  
     It has identity.  That is, one object instance is distinct from any other object instance (even another of the same
     type).  This implies that each has its own memory allocation and so its own copy of any state variables.  Sending a
     message to one instance is independent of sending a message to another instance.

  3. **Lifetime:**  
     It has a well-defined lifetime.  Once all references (including remote capabilities) to an object have been
     discarded, the object is no longer reachable and can itself be discarded.

  4. **Actions:**  
     It has a well-defined type whose specification is provided by the Interface that it implements.  The object MUST
     provide an implementation for all _actions_ that might be called on it through a proxy capability (and subsequently
     dispatched by the message passing system).  As we saw in the post [RPC Part 1][devlog-post3], Promise RPC's code
     generator defines an `abstract class` from which to derive an implementation for each Interface.  An instance of
     this implementation `class` statisfies the contract of its corresponding capability.

If our message passing system supports Capability Exchange, we can define a second interface for our chat server:

```csharp
[Eventual]
interface IChatRoomManager
{
  ChatProxy CreateRoom(string name);
}
```

This then provides more insight into the code we saw above:

```csharp
ChatProxy videoGameReview = crm.CreateRoom("Video Game Review");
ChatProxy cookingRecipes = crm.CreateRoom("Cooking Recipes");

await videoGameReview.Chat("Marymoor Studios [b]rocks[/b]!");
await cookingRecipes.Chat("No, the secret is to use half-and-half instead of milk!");
```

The `CreateRoom` method creates a new distinct `ChatRoom` object instance and then returns a capability to it.  The
`Chat` method dispatches a new activity which includes an implicit reference to the target `ChatRoom` object.  In
Promise RPC, `Chat` is an abtract instance method on the `ChatRoom` object that is called by the message passing system
within the dispatch activity.  This `this` pointer gives access to the object's state.

## Capability Arguments
In the above example, we create new chat rooms and then use their capabilities to send independently ordered messages.
But how do other members participate?  We need a way to give another user access to a chat room's capability. 

To explore how we might do this, let's define an Interface to represent an individual chat user:

```csharp
[Eventual]
interface IUser
{
  Promise Invite(ChatProxy room);
}
```

Unlike the previous examples where a capability was returned from a method, the `Invite` method _takes_ a capability as
an argument.  As we mentioned above, capabilities can be exchanged in either direction by the message passing system.
Now we can invite other users to participate in the chat rooms we created by passing them the chat room capability:

```csharp
ChatProxy videoGameReview = crm.CreateRoom("Video Game Review");
await alice.Invite(videoGameReview);
await bob.Invite(videoGameReview);
ChatProxy cookingRecipes = crm.CreateRoom("Cooking Recipes");
await bob.Invite(cookingRecipes);
await carol.Invite(cookingRecipes);

await videoGameReview.Chat("Marymoor Studios [b]rocks[/b]!");
await cookingRecipes.Chat("No, the secret is to use half-and-half instead of milk!");
```

Bob is a member of both rooms, while Alice and Carol are only members of one each.

## Object Id Comparison
How is a capability any different than a plain old object id (like the one we saw as the `chatRoomId` parameter in the
example above)?  Remember we skipped over a set of possible issues with object ids earlier.  Let's revisit those issues
and see if our capability solution addresses any of them.

  1. **Who allocates the id?**
     Unlike with an object id, there is no program-visible id in the capability programming model.  Ids don't need to be
     allocated by the server.

  2. **How does the caller learn the id?**  
     The caller is given a capability through an earlier exchange.  In the above example, the `CreateRoom` method
     returns a capability.  Of course, `CreateRoom` could just as easily return an object id, so this is not
     significantly different.
  
  3. **How do you prevent the same id from being used for multiple rooms at the same time?**  
     With a capability design there is no program-visible id.  The server implementation doesn't have to do anything to
     ensure that a capability is unique.  The constructor for a capability takes a direct reference to a target object
     of the appropriate type.  So, only the server (which has direct access to the target object) can create a new
     capability.  Any other capability would need to be created by the message passing system as part of a capability
     exchange.  The message passing system then properly associates that capability with its target object.
     Automatically.  
     
     When using an explicit object id, the server would have to keep a table somewhere that lists all object ids in use
     so that when allocating a new id it would know not to allocate the same id to two different objects.
  
  4. **How do you prevent malicious users from guessing the id of rooms they aren't a member of?**  
     In a capability-based system you can only perform actions on capabilities that you hold.  If you were never given a
     capability, then there is no way to perform an action on it.  Since capabilities are unforgeable, there is no way
     for a malicious user to create their own copy of the capability without the server's involvement.  Members of the
     chat room are simply defined by those who were given the capability, while those who were not are not members.
     Guaranteed.

     When dealing with an object id, however, security is more nuianced.  An object id is just a number passed as an
     argument.  A malicious user could attempt to guess the right number (say by trying all of the numbers, or guessing
     randomly).  No guarantees can be made that a malicious user might not get lucky.  Some other security mechanism
     would have to also be in place.  Perhaps the chat room could keep a list of all its members (i.e. an Access Control
     List, or ACL), and then check that list at the beginning of every call to the `Chat` method?  This check is
     expensive, complex, and requires there be some way to accurately identify who the caller is.  An ACL converts the
     problem of authorization into a problem of authentication.  
     
     The capabilities-based design doesn't have any of these problems.  We haven't even talked about authentication or
     user identity, and yet we still have a secure system without them.

  5. **When a room is destroyed, how to you reuse the id (so you don't run out)?**  
     In a capability-based system the capabilities and the objects they reference each have a lifetime.  When a
     capability is discarded its reference to the target object is released.  When all of the references to an object
     are discarded then the object's lifetime has ended.  There is no object id to reuse, and a `ChatRoom` is
     automatically destroyed when all its members leave.  Additionally, capabilities are attached to connected sessions.
     When a connected session ends (e.g. because of disconnection, or because one of the parties terminates), all
     outstanding capabilities on that session are automatically released.  In this way, capabilities cannot be lost or
     leaked, and their lifetimes are always bounded.  Capability and object lifetimes are tracked by the message passing
     system.  _Automatically_.

     When using an object id, however, the id itself is just a number.  Once passed from the server to the caller, there
     is no way for the server to track the subsequent lifetime of that number.  Did the caller store the object id in a
     memory variable, or drop it on the floor?  Either, the server must rely on the caller to tell them when they are
     done using an id, or the server must attach its own lifetime to the object (e.g. with a lease or ticket) and then
     require the caller to periodically tell the server if the object is still in use (e.g. by renewing the lease, or
     acquiring a new ticket).  All of this adds complexity to the caller, the server's implementation, and the protocol.
     All of this complexity must be repeated for each application.  And despite this complexity, the lifetime bounds for
     resource use at the server will NOT be tight.  The server's lease will inevitably be _longer than_ the actual use,
     leading the server to keep resources around longer than necessary, reducing overall efficiency.
  
  6. **During message dispatch, how do you find the data structure that manages that specific room's data?**  
     In the capability-based system the implicit reference to the target object provides direct access to the object's
     state during message dispatch.  No additional bookkeeping is necessary on the part of the server implementation.

     When using an object id, the server would have to maintain a mapping between active object ids and their associated
     state.  This table could easily be combined with the table used for id allocation in (1) and id uniqueness in (3)
     above.  This table would need be consulted explictly during each dispatch to convert the object id argument into a
     reference to the associated state.

All in all, there _are_ ways to address these issues when using object ids, but capabilities provides elegant,
automatic, built-in, and highly efficient solutions.

## The Root Capability
The first capability received when successfully initiating a new connected session.  The root capability is made
available directly as a result of session establishment and doesn't require any additional method to be called.  This is
the ONLY capability that is delivered without a method call.  All other reachable capabilities MUST be obtained through
some sequence of calls to either the root capability or another capability returned directly or indirectly from the
root.  Each party exports their own root capability to the opposite party in a bidrectional session.  Either party may
export the `Nothing` capability if _no actions are authorized_ in that direction.

## Example

## Conclusion
In this post we talked about capabilities, capability exchange, and both can be used to build secure, efficient, and
easy to use systems.  We gave some examples of how [Promise RPC library's](
https://www.nuget.org/packages/MarymoorStudios.Core.Rpc/) implementation of capabilities can be used to implement common
game constructs.

This is Part 3 of our look at the [MSC][MSC] RPC system.  In Part 4 and beyond we'll look at streaming with sequences
and bytes, and finally we'll see how channel lifetime relates to aborts and cancellation. Until next time, code on!

## Previous
Read the [previous post][devlog-post4] in this series.

## Feedback
Write us with [feedback][feedback].

## See Also
* [All Posts][all-posts]
* [Glossary][glossary]
* [MSC (Marymoor Studios Core libraries)][MSC]

[MSC]: https://github.com/MarymoorStudios/Core
[all-posts]: /devlog.html
[devlog-post2]: /devlog/2025-04-23-Ordering
[devlog-post3]: /devlog/2025-05-29-RPC1
[devlog-post4]: /devlog/2025-06-30-RPC2
[feedback]: mailto:feedback@marymoorstudios.com
[glossary]: /devlog/Glossary
[async-keyword]: https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/async
[await-keyword]: https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/await
[distributed-computing]: https://en.wikipedia.org/wiki/Distributed_computing
[capability-based_security]: https://en.wikipedia.org/wiki/Capability-based_security
[oop]: https://en.wikipedia.org/wiki/Object-oriented_programming
